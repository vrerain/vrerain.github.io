<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法之深搜与广搜</title>
      <link href="/2020/02/11/suan-fa-zhi-shen-sou-yu-guang-sou/"/>
      <url>/2020/02/11/suan-fa-zhi-shen-sou-yu-guang-sou/</url>
      
        <content type="html"><![CDATA[<p>   在经过8次算法课的学习后，自己的能力提升了很多，只不过对于学的知识很多都不是很懂，懂的中也有一些很不熟练，先将自己较为熟练的深搜与广搜做一个整理；</p><p>   深度优先搜索（Depth-First-Search）其概念简要的说就是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.该算法用到的事递归思想；递归需要两个部分：基线条件和递归条件；</p><p> <img src="https://img-blog.csdnimg.cn/20190606074319646.png?xk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>   我们从a出发，先到b,再到e,之后回去，到b,再到c,c再回到f,f再回到b,b再回到a,再从a到d,再从d到g,再从g回到d，再从d回到a,发现所有节点都已经遍历，深度搜索结束；</p><p>   总的来说，深度优先搜索，就是一条路走到底的策略，直到再也不能走为止，这种思想正是可以用递归实现的，因此用深度优先搜索，设立一个停止条件（即没有搜索的东西），然后一次一次的向下递归，直到遍历了所有的节点</p><pre><code>void dfs()//参数用来表示状态  {      进行一些操作，由题目决定    if(到达终点状态)      {         return;      }      if(不符合题意)          return;      if(符合题意)       {          修改操作;        dfs（）；         }    }  </code></pre><p>dfs的题目分为两大类，第一类时在图上进行深搜，图可以选择邻接矩阵进行存储（也可以用vector或者前向星来存储，邻接矩阵比较简单，但是如果点过多的话，就不适用了)，之后再进行遍历，接下来有几道基础题:</p><p>B - Counting Sheep        HDU-2952<br>连通块类的问题，从起点开始上下左右四个方向进行搜索，搜索到的都标记为无羊，表示自己已经搜索过这里，当完全搜不到时，计数器便自加，在搜索下一个有羊的区域，同样还有八个方向的搜索的题目，同理。</p><p>代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};//定义搜索方向int n,row,line,number;char a[105][105];//存储图的数组void dfs(int i,int j){    a[i][j]='.';    for(int q=0;q&lt;4;q++){        int nx=i+dx[q],ny=j+dy[q];        if(nx&gt;=0&amp;&amp;nx&lt;row&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;line&amp;&amp;a[nx][ny]=='#'){            dfs(nx,ny);//用递归向其他方向搜索        }    }    return ;}int main(){    //freopen("t.txt","r",stdin);    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){            int ans=0;        cin&gt;&gt;row&gt;&gt;line;        for(int j=0;j&lt;row;j++)            cin&gt;&gt;a[j];        for(int i=0;i&lt;row;i++){            for(int j=0;j&lt;line;j++){                if(a[i][j]=='#'){                    dfs(i,j);                    ans++;                }            }        }    printf("%d\n",ans);    }    return 0;}</code></pre><p>A - 棋盘问题                POJ-1321<br>此题与n皇后问题很像，即放一棵棋子，之后对所有放置其他棋子的方式，进行搜索，直到找到，计数器自加，其中要保证行和列不能有两枚棋子；</p><p>代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char a[10][10];//记录棋盘位置int book[10]={0};int n,k,cnt,m;void dfs(int cur){    if(k==m)//终点状态    {        cnt++;        return ;    }    if(cur&gt;=n)//不符合题意        return ;    for(int j=0; j&lt;n; j++)        if(book[j]==0 &amp;&amp; a[cur][j]=='#')        {            book[j]=1;            m++;            dfs(cur+1);            book[j]=0;            m--;        }    dfs(cur+1);}int main(){    //freopen("t.txt","r",stdin);    int i,j;    while(scanf("%d%d",&amp;n,&amp;k)&amp;&amp;n!=-1&amp;&amp;k!=-1)//限制条件    {        cnt=0;        m=0;        for(i=0; i&lt;n; i++)            for(j=0;j&lt;n;j++)            scanf("%c",&amp;a[i][j]);        dfs(0);        printf("%d\n",cnt);    }    return 0;}</code></pre><p>第二类数据类</p><p>这类题本人也没怎么做过，直接放题：<br>HDU 1015-Safecraker(回溯，字符处理)</p><p>接下来时bfs：<br>bfs也是运用递归的思想，不过其运用了队列的数据结构，队列的特性是，先进先出，与栈的先进后出是不同的，废话不多说，放张关于队列的图：<br><img src="https://img-blog.csdnimg.cn/20190606191654613.png" alt=""><br>详细用法:<br>定义一个queue的变量     queue<type> M<br>查看是否为空范例        M.empty()    是的话返回1，不是返回0;<br>从已有元素后面增加元素   M.push()<br>输出现有元素的个数      M.size()<br>显示第一个元素          M.front()<br>显示最后一个元素        M.back()<br>清除第一个元素          M.pop()<br>（需要加上queue的头文件声明)</type></p><p>bfs也就是利用队列先进先出的性质，对图进行一层一层的搜索，直到找到元素为止，bfs多用于求图上的到达某点的最短路径（做题甚少，只知道这种题型），即多用于迷宫问题。<br>例题：<br>给定一个大小为N*M的迷宫，由通道(‘.’)和墙壁(‘#’)组成，其中通道S表示起点，通道G表示终点，每一步移动可以达到上下左右中不是墙壁的位置。试求出起点到终点的最小步数。（本题假定迷宫是有解的）(N,M&lt;=100)<br>样例输入：10 10<br><img src="https://img-blog.csdnimg.cn/20190612184710137.png" alt=""><br>样例输出：22</p><p>代码：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std; int m,n;const int INF =100000000;typedef pair&lt;int,int&gt; P;char maze[200][200];int sx,sy;int gx,gy;int d[200][200];void panduan(int m,int n){    for(int i=0;i&lt;m;i++)    for(int j=0;j&lt;m;j++){        if(maze[i][j]=='S'){            sx=i;            sy=j;        }        if(maze[i][j]=='G'){            gx=i;            gy=j;        }    }}int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};int bfs(){    queue &lt;P&gt; que;    for(int i=0;i&lt;n;i++)    for(int j=0;j&lt;n;j++){        d[i][j]=INF;    }    que.push(P(sx,sy));//将起点加入对列，并且设置其距离为0    d[sx][sy]=0;    while(que.size()){        P p=que.front();        que.pop();        if(p.first==gx&amp;&amp;p.second==gy)break;        for(int i=0;i&lt;4;i++){            int nx=p.first+dx[i];            int ny=p.second+dy[i];            if(0&lt;=nx&amp;&amp;nx&lt;n&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;m&amp;&amp;maze[nx][ny]!='#'&amp;&amp;d[nx][ny]==INF){                que.push(P(nx,ny));                d[nx][ny]=d[p.first][p.second]+1;            }        }    }    return d[gx][gy];}int main(){    //freopen("t.txt","r",stdin);    scanf("%d%d",&amp;m,&amp;n);    for(int i=0;i&lt;m;i++)    for(int j=0;j&lt;n;j++){        scanf("%c",&amp;maze[i][j]);    }    panduan(m,n);    int res=bfs();    printf("%d\n",res);    return 0;}</code></pre><p>F - 非常可乐  HDU-1495</p><p>   这个题，一共有六种动作，瓶倒杯1，杯1到瓶，瓶到杯2，杯2到瓶，杯一到杯2，杯2到杯1。6种动作是平行的，属于同一级别，之后对每种动作进行搜索，停止条件为有两个容器中有相同的可乐，用一个东西计算搜索的次数，即为答案。</p><pre><code>#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int s[3];int book[105][105][105];标记某种状态是否走过int half;struct cup{    int c[3];    int a;}p,temp;void init(){    for(int i=0;i&lt;105;i++)        for(int j=0;j&lt;105;j++)            for(int k=0;k&lt;105;k++)                book[i][j][k]=0;    book[s[0]][s[1]][s[2]]=1;//最初始状态}void bfs(){    queue &lt;cup&gt; q;    p.c[0]=s[0];    p.c[1]=0;    p.c[2]=0;    p.a=0;    q.push(p);//把初始状态压入队列中    while(q.empty()==0)    {        p=q.front();        q.pop();        for(int i=0;i&lt;3;i++)        {            if(p.c[i]&gt;0)            {                for(int j=0;j&lt;3;j++)                {                    temp=p;                    if(i==j)                        continue;                    if(temp.c[i]&gt;s[j]-temp.c[j])//可以倒水，且倒满了                    {                        temp.c[i]-=s[j]-temp.c[j];                        temp.c[j]=s[j];                    }                    else{                               //倒不满                        temp.c[j]+=temp.c[i];                        temp.c[i]=0;                    }                    if(book[temp.c[0]][temp.c[1]][temp.c[2]]==0)                    {                        book[temp.c[0]][temp.c[1]][temp.c[2]]=1;                        temp.a++;                        int d=0;                        for(int k=0;k&lt;3;k++)                        {                            if(temp.c[k]==half)                                d++;                        }                        if(d==2)                        {                            cout&lt;&lt;temp.a&lt;&lt;endl;                            return;                        }                        q.push(temp);                    }                }            }        }    }    printf("NO\n");}int main(){    //freopen("t.txt","r",stdin);    while(1)    {    for(int i=0;i&lt;3;i++)    {        cin&gt;&gt;s[i];    }    if(s[0]==0&amp;&amp;s[1]==0&amp;&amp;s[2]==0)        break;    init();    if(s[0]%2)        cout&lt;&lt;"NO"&lt;&lt;endl;    else{        half=s[0]/2;        bfs();    }    }    return 0;}</code></pre><p><strong>搜索的优化:</strong></p><ol><li><p>记忆化搜索：<br> 所谓记忆化搜索就是，在每次状态转移的时候，判断一下这个状态是否已经转移过了，如果转移过了，直接调用他的结果就好了，这可以减小搜索的时间复杂度，并且避免了向栈中压入过多的数据，导致爆栈的错误（不过本人表示从未遇到爆栈的错误。）<br> 例题：<br> 洛谷  p3953<br> 洛谷自带题解！！！</p></li><li><p>剪枝：<br> 剪枝也就是将一些不符合规则的树枝剪掉，来减小时间复杂度<br>例题:<br>POJ  1011<br><a href="https://blog.csdn.net/sj2050/article/details/80645121" target="_blank" rel="noopener">附带详细题解</a></p></li><li><p>双向搜索:<br> 所谓双向搜索，就是从上往下，从下往上一块搜索，之后再“合并数据”，由于自己也不懂，所以附上一篇博文来解释<br> <a href="https://blog.csdn.net/thudaliangrx/article/details/50659007" target="_blank" rel="noopener">双向搜索博客</a></p></li><li><p>迭代加深<br> 所谓迭代加深，就是设定一定的层数限制，然后进行搜索，如果搜不到，则加深层数，直到最后一层为止，这样避免了所要找的结果在很低的层数却花了很长的时间去找</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20190608095837525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""></p><p>例如上图这种情况，如果照常规方法去搜索，那么需要遍历所有节点才能找到，但是如果采用迭代加深的方法，设定一定的层数限制，就可以很快找到。</p><p>自己了解的搜索算法，到这里就没了，没发过什么博文，如果有错误和不当的地方，敬请指正。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次基于hexo博客主题的博客搭建全过程</title>
      <link href="/2020/02/11/ji-lu-yi-ci-ji-yu-hexo-bo-ke-zhu-ti-de-bo-ke-da-jian-quan-guo-cheng/"/>
      <url>/2020/02/11/ji-lu-yi-ci-ji-yu-hexo-bo-ke-zhu-ti-de-bo-ke-da-jian-quan-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo框架部署到github-coding，并修改域名"><a href="#hexo框架部署到github-coding，并修改域名" class="headerlink" title="hexo框架部署到github+coding，并修改域名"></a>hexo框架部署到github+coding，并修改域名</h2><h4 id="部署到github上："><a href="#部署到github上：" class="headerlink" title="部署到github上："></a>部署到github上：</h4><ol><li><p>首先需要下载能让node.js环境，node.js官网下载即可，这里推荐下载lts版本(长期支持版),之后就是傻瓜式安装，一直下一步，安装之后打开cmd,这时可以输入命令<code>node -v</code>和<code>npm -v</code>来查看自己是否安装成功。  <img src="https://img-blog.csdnimg.cn/20200209215235503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""></p></li><li><p>装完之后我们就可以使用npm命令，由于npm安装东西时，访问的时国外的服务器，所以我们这里引用淘宝的镜像源，这样就可以下载速度更快一些,cmd终端输入</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>3.然后就可以使用淘宝镜像源下载东西了，首先安装hexo框架<code>cnpm install -g hexo-cli</code>，（因为绑定淘宝镜像源后就可以用cnpm代替npm了）<br>4.建立一个放博客的目录，然后到这个目录下，cmd输入代码<code>hexo init</code>，一段时间后，初始化完成后，目录就会多许多文件，如下：<br><img src="https://img-blog.csdnimg.cn/20200211151548308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>5.然后cmd下输入命令：<code>hexo s</code>(即启动hexo服务),游览器进入网址120.0.0.1:4000,这时会看到以下页面：<br><img src="https://img-blog.csdnimg.cn/20200211151802322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>这是hexo默认的一个主题，如果想更换，可以在官网找主题下载，这是主题<a href="https://hexo.io/themes/" target="_blank" rel="noopener">传送门</a>，<br><img src="https://img-blog.csdnimg.cn/20200211152052787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt="">)点击图片即预览主题，点击名字即进入主题下载，我这里推荐的是matery主题，这是下载<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.3eded9b9WNoIgB&amp;url=https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">传送门</a><br>如果想更换其他主题，只需在相应的下载界面下载zip压缩文件即可，如下：<img src="https://img-blog.csdnimg.cn/20200211152448348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>下载之后解压，把整个文件夹复制到自己博客目录的themes下<br><img src="https://img-blog.csdnimg.cn/2020021115274332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>文件夹的名字改为matery，<br>6.这时在根目录下有一个_config的文件主题文件夹也有对应的_config的文件，这分别对应博客配置文件，主题配置文件。打开博客配置文件<br><img src="https://img-blog.csdnimg.cn/20200211153154170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>title、author、都可以改，language：改为zh-CN,<br>url可以改为自己的域名，<br>滑到最后，把theme改为matery,（注意:后面有一个空格)<br>这时保存，cmd下，依次运行命令，<code>hexo clean</code> (清理） ,<code>hexo g</code>（生成）,<code>hexo s</code>（运行）再打看游览器进入网址即可看到如下页面：<br><img src="https://img-blog.csdnimg.cn/20200211154054116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt="">主题即替换成功。<br>7.进入github官网，注册账号后，新建一个仓库，细节如下：<br><img src="https://img-blog.csdnimg.cn/20200211154541949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>8.建立好之后，进入博客设置中：</p></li></ol><pre><code>type: gitrepo: git@github.com:Github用户名/github用户名.github.io.git  //也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git            branch: master</code></pre><p><img src="https://img-blog.csdnimg.cn/20200211154703996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>配置好之后，这时需要向github仓库中推文件的插件，<br>cmd下运行命令<code>cnpm install hexo-deployer-git --save</code><br>然后，运行代码，<code>hexo clean</code>,<code>hexo g</code>,<code>hexo d</code><br>(注意：这里会弹出相应的弹窗让你输入用户名和密码的，下面的coding部署也同理)<br>这时游览器输入你的仓库名，例如vrerain.github.io,这时就会看到你的博客页面，相应配置的修改，包括评论系统的添加，都可以看<a href="https://yq.aliyun.com/articles/742964" target="_blank" rel="noopener">这篇文章</a>，这里就不多说了。</p><h4 id="部署到coding上"><a href="#部署到coding上" class="headerlink" title="部署到coding上"></a>部署到coding上</h4><p>1.注册，新建团队，团队名称自己随意，然后新建项目，新建一个DevOps项目：<br><img src="https://img-blog.csdnimg.cn/20200211155652446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>然后复制自己的项目地址：<br><img src="https://img-blog.csdnimg.cn/20200211155801268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>将自己博客的博客配置文件中的repo：改为如下样子，但是相应的地址改为自己的：<br><img src="https://img-blog.csdnimg.cn/20200211160026278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>然后接着执行三条命令：<code>hexo clean</code>,<code>hexo g</code>,<code>hexo d</code><br>这时相应的coding仓库也有了相应的博客文件。</p><p>这里之所以再把相应的文件部署到coding上，是因为国内访问github太慢，这样我们就可以国外访问github,国内访问coding</p><h4 id="相应的域名配置"><a href="#相应的域名配置" class="headerlink" title="相应的域名配置"></a>相应的域名配置</h4><p>1.这里以阿里云域名为例<br>首先添加国外域名解析，<br><img src="https://img-blog.csdnimg.cn/20200211161014815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>然后就可以进行解析，然后进入github对应的仓库，进入设置，找到如下设置，并改为：<br><img src="https://img-blog.csdnimg.cn/2020021116124792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>设置好之后，如果游览器输入仓库名，跳转到你的域名即设置成功，<br>这里域名解析是需要时间的，可能是一晚上，也可能是一天，只要输入自己的域名能看到自己的博客就算成功（这里可能会报非私密连接，不过是可以访问的）</p><p>2.当国外的解析好之后，就进入了coding的过程，<br>打开coding你的项目的管理页，找到构建与部署选项下的构建静态网站，发布静态网站，保存后，点击立即部署：<br><img src="https://img-blog.csdnimg.cn/20200211162008599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>（这里的访问地址只有最下面的网址）<br>点击对应的访问地址，会看到自己的博客页面。<br>然后阿里云域名添加coding解析：如下图<br><img src="https://img-blog.csdnimg.cn/20200211162812721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""></p><p>3.点击2的第一张图的设置，修改以下配置：<br>（这里要在阿里云的域名解析中把国外的解析暂时关掉，否则证书会申请失败）<br><img src="https://img-blog.csdnimg.cn/20200211162300685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""><br>证书申请成功后，域名解析成功后，就可以通过域名访问自己的博客了，并且因为coding是国内的服务器，访问速度很快</p><h5 id="到这里文章就结束了，如果有不对的地方，敬请指正。"><a href="#到这里文章就结束了，如果有不对的地方，敬请指正。" class="headerlink" title="到这里文章就结束了，如果有不对的地方，敬请指正。"></a>到这里文章就结束了，如果有不对的地方，敬请指正。</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django简单版部署服务器</title>
      <link href="/2020/02/09/django-jian-dan-ban-bu-shu-fu-wu-qi/"/>
      <url>/2020/02/09/django-jian-dan-ban-bu-shu-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<p>首先这是一次没有域名的部署，所以，过程十分的简单，首先本人用的是ubuntu18.04,里面自带了python3,所以就无需再安装python3</p><ol><li>输入命令<code>apt-get update</code>,更新系统程序。</li><li>安装pip3,输入命令<code>apt install python3-pip</code></li><li>安装虚拟环境，到一个合适的文件夹下，然后输入命令<code>pip3 install virtualenv</code>这样就安装好了相应的虚拟环境。</li><li>建立虚拟环境，输入<code>virtualenv --python=/usr/bin/python3 pyweb</code></li><li>激活虚拟环境，进入pywev/bin目录中,输入命令<code>source activate</code></li><li>安装django，<code>pip3 install django==2.1</code>.这里用的是2.1版本，然后建立django项目。</li><li>阿里云一些配置，找到自己服务器的本实例安全组，然后新建规则，配置如下图<img src="https://img-blog.csdnimg.cn/20200204213757836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDI4Mjkw,size_16,color_FFFFFF,t_70" alt=""></li><li><code>python manage.py runserver 0.0.0.0:8000</code>(自己建立的django项目中的settings.py，相应代码中改为<code>ALLOWED_HOSTS = ['*']</code></li><li>之后游览器输入<code>公网ip :8000</code>就可以看到django的页面。</li><li>若想关闭终端依旧运行django,则需要将8中的命令换为:<code>nohup python manage.py runserver 0.0.0.0:8000 &gt;log 2&gt;1&amp;</code>命令即可</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
